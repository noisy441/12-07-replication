# Домашнее задание к занятию «Репликация и масштабирование. Часть 2» - Дудин Сергей Васильевич

### Инструкция по выполнению домашнего задания

1. Сделайте fork [репозитория c шаблоном решения](https://github.com/netology-code/sys-pattern-homework) к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/gitlab-hw или https://github.com/имя-вашего-репозитория/8-03-hw).
2. Выполните клонирование этого репозитория к себе на ПК с помощью команды `git clone`.
3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
   - впишите вверху название занятия и ваши фамилию и имя;
   - в каждом задании добавьте решение в требуемом виде: текст/код/скриншоты/ссылка;
   - для корректного добавления скриншотов воспользуйтесь инструкцией [«Как вставить скриншот в шаблон с решением»](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md);
   - при оформлении используйте возможности языка разметки md. Коротко об этом можно посмотреть в [инструкции по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md).
4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`).
5. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
6. Любые вопросы задавайте в чате учебной группы и/или в разделе «Вопросы по заданию» в личном кабинете.

Желаем успехов в выполнении домашнего задания.

---

### Задание 1

Опишите основные преимущества использования масштабирования методами:

- активный master-сервер и пассивный репликационный slave-сервер; 
- master-сервер и несколько slave-серверов;


*Дайте ответ в свободной форме.*

---

### Решение 1

#### Преимущества масштабирования

#### Активный master-сервер и пассивный slave-сервер
Данная модель репликации, где один сервер (Master) отвечает за запись данных, а его точная копия (Slave) постоянно синхронизируется с ним, предоставляет ряд ключевых преимуществ для построения стабильных систем:
1. **Отказоустойчивость**: В случае выхода из строя master-сервера, slave может быть быстро переведен в режим master, что минимизирует время простоя.
2. **Балансировка нагрузки**: Запросы на чтение данных (SELECT) можно перенаправлять на резервный сервер. Это разгружает основной сервер, позволяя ему эффективнее обрабатывать более ресурсоемкие операции записи (INSERT, UPDATE, DELETE).
3. **Резервное копирование**: На slave-сервере можно выполнять резервное копирование без влияния на производительность master.
4. **Тестирование и аналитика**: Slave можно использовать для тестирования обновлений или выполнения аналитических запросов, не нагружая основной сервер.
5. **Защита от человеческого фактора**: Случайное выполнение деструктивной операции (например, DROP TABLE или DELETE без WHERE) на основном сервере не мгновенно уничтожает данные. Есть небольшое окно времени, чтобы остановить репликацию и восстановить данные с резервной копии Slave-сервера, который еще не успел применить ошибочную команду.
6. **Географическое разделение**: Slave-сервер можно физически разместить в другом дата-центре или регионе. Это защищает данные от потери в случае полного разрушения или недоступности основного центра (пожар, отключение электричества, сетевые проблемы).<
   
#### Один master-сервер и несколько slave-серверов
Эта модель, часто называемая «горизонтальным масштабированием на чтение», является мощным развитием простой Master-Slave пары и предоставляет следующие ключевые преимущества:
1. **Массовое масштабирование операций чтения (Read Scalability)**. Запросы на чтение (SELECT) распределяются (балансируются) между несколькими slave-серверами.  Такая система способна обслуживать экспоненциально большее количество пользователей и одновременных запросов. Это прямое решение для роста трафика и высокой читающей нагрузки, типичной для большинства веб-приложений, мобильных API и интернет-магазинов. Добавление новых slave-серверов позволяет почти линейно наращивать мощность для чтения.
2. **Глобальное размещение**. Размещение подчинённых серверов в различных географических точках сокращает время отклика для пользователей в разных регионах.  Даже если целый дата-центр станет недоступен, пользователи из других регионов смогут работать с данными через своих локальных slave'ов.
3. **Повышенная надёжность**. Если один из slave-серверов выходит из строя, балансировщик нагрузки автоматически перенаправляет трафик на оставшиеся рабочие slave-серверы. Пользователи даже не заметят сбоя на одном из узлов. Система продолжает работать в штатном режиме, обеспечивая бесперебойный доступ к данным для чтения. Это создает отказоустойчивый кластер для операций чтения.
4. **Упрощение технического обслуживания**. Любые работы на отдельных slave-серверах (апгрейд ОС, установка патчей, перезагрузка) можно проводить поочередно, без остановки всего сервиса. Сервер просто выводится из пула балансировки, обслуживается, а затем возвращается обратно. Пользователи используют другие реплики, не замечая проводимых работ.
5. **Специализация задач**. Каждый подчинённый сервер может выполнять определённые функции: резервное копирование, формирование отчётов, тестирование обновлений.

**Вывод** - внедрение репликации данных является мощным инструментом для построения надежных и производительных систем. Конфигурация с одной репликой подходит для обеспечения базовой отказоустойчивости и разгрузки основного сервера, в то время как использование нескольких реплик является стандартным решением для высоконагруженных проектов с интенсивной читающей нагрузкой.

---

### Задание 2


Разработайте план для выполнения горизонтального и вертикального шаринга базы данных. База данных состоит из трёх таблиц: 

- пользователи, 
- книги, 
- магазины (столбцы произвольно). 

Опишите принципы построения системы и их разграничение или разбивку между базами данных.

*Пришлите блоксхему, где и что будет располагаться. Опишите, в каких режимах будут работать сервера.* 

---

### Решение 2

Перед проектированием шардинга необходимо понять, какие данные и как будут использоваться.

База данных состоит из следующих таблиц:

Пользователи (users)

Столбцы : ```user_id```, ```email```, ```name```, ```registration_date```, ```country_code```, ```city```.
> Очень частые операции записи (регистрация, обновление профиля). Частые операции чтения (логин, просмотр профиля). Распределение пользователей по странам/городам часто неравномерное.

Книги (books)

Столбцы : ```book_id```, ```title```, ```author_id```, ```genre```, ```published_year```, ```price```.
> Относительно редкие операции записи (добавление новой книги). Очень частые операции чтения (поиск, просмотр каталога, фильтрация). Данные относительно статичны.

Магазины (shops)

Столбцы: ```shop_id```, ```name```, ```location```, ```manager_id```.
> Очень редкие операции записи (добавление/закрытие магазина). Частые операции чтения (привязка заказов, просмотр информации). Данные очень статичны.


### План постороения вертикального шардинга.

Принцип: Разделение таблиц по функциональности между разными серверами.

- Сервер 1 (Master)
   - users (основные данные пользователей)
   - shops (информация о магазинах)
   - Режим: Read-Write (записи и чтение)
     
Тип рабочей нагрузки: Write-Intensive (нагрузка, ориентированная на запись). Частые операции INSERT (регистрация), UPDATE (изменение профиля, данных магазина). Требования к согласованности: Высокие. Нельзя допустить, чтобы пользователь изменил пароль, а система продолжила пускать его со старым. На этом сервере можно настроить индексы, кэширование и параметры сервера именно под интенсивную нагрузку на запись, не мешая операциям чтения из каталога книг. Легко поддерживать ссылочную целостность между users и shops. Можно строже ограничить доступ к критическим пользовательским данным.
   
- Сервер 2 (Slave)
   - books (каталог книг)
   - Режим: Read-Only (масштабирование чтения)
 
Тип рабочей нагрузки: Read-Intensive (нагрузка, ориентированная на чтение). Преобладают операции SELECT (поиск, фильтрация, просмотр). Требования к согласованности могут быть более слабыми ( eventual consistency ). Небольшая задержка (несколько секунд или минут) между добавлением новой книги и ее появлением в поиске приемлема. Этот сервер можно очень легко масштабировать. Можно создать несколько реплик (Slaves) сервера 2 и распределять между ними читающие запросы с помощью балансировщика нагрузки. Это значительно увеличит пропускную способность для поиска и каталога. Высокая нагрузка на каталог книг (например, во время распродажи) не повлияет на критически важные процессы регистрации пользователей или оформления заказов.

![вертикальная схема](https://github.com/noisy441/12-07-replication/blob/main/img/img1.png)

### План постороения горизонтального шардинга.

Принцип: Разделение одной таблицы на части (шарды) по определённому ключу. Очень важно выбрать правильный ключ

1. Пользователи (users)
Ключ шардирования: country_code (код страны)

- Схема:
   - Шард 1 (Северная Америка): users WHERE country_code IN ('US', 'CA', 'MX')
   - Шард 2 (Европа): users WHERE country_code IN ('DE', 'FR', 'UK', 'ES', 'IT', ...)
   - Шард 3 (Азия): users WHERE country_code IN ('CN', 'JP', 'KR', 'IN', ...)
   - Шард N (Остальной мир): Для всех остальных стран. Можно объединять в регионы.

Обоснование:
1. Географическая локализация: Большинство запросов к данным пользователя (логин, просмотр профиля) происходят в рамках одной страны или региона. Это гарантирует, что эти запросы будут обрабатываться только одним шардом, что минимизирует задержки.
2. Юридическое соответствие: Упрощает соблюдение законов о данных (как GDPR), так как данные пользователей из определенных юрисдикций физически находятся на выделенных серверах.
3. Эффективное масштабирование: Позволяет добавлять шарды для новых быстрорастущих регионов или для стран с огромной пользовательской базой (например, выделить отдельный шард для пользователей из Индии). Проблема неравномерного распределения решается на уровне шардов, а не отдельных записей.

2. Книги (books)
Ключ шардирования: genre (жанр) или author_id

- Схема (на примере genre):
   - Шард 1 (Художественная лит.): books WHERE genre IN ('Фантастика', 'Фэнтези', 'Роман')
   - Шард 2 (Нехудожественная лит.): books WHERE genre IN ('Наука', 'История', 'Биография', 'Программирование')
   - Шард 3 (Прочее): books WHERE genre IN ('Поэзия', 'Драма', 'Детские', 'Комиксы')

Обоснование:
1. Паттерны доступа: Пользователи чаще всего ищут и просматривают книги в рамках определенного жанра или автора. Шардирование по жанру группирует данные, которые запрашиваются вместе, на одном шарде.
2. Распределение нагрузки: Равномерно распределяет нагрузку от чтения между шардами. Запрос на подборку книг в жанре "Фэнтези" будет выполняться целиком на одном сервере, а не сканировать все серверы кластера.
3. Управление ростом: Разные жанры могут иметь разный объем данных (например, научной литературы может быть меньше, чем романов). Это позволяет масштабировать каждый жанр по отдельности based on its size.

3. Магазины (shops)
Горизонтальное шардирование не требуется.

Обоснование:
1. Небольшой объем: Таблица справочной информации. Даже у крупнейших сетей количество магазинов исчисляется тысячами, а не миллионами. Это легко помещается в оперативную память одного сервера БД.
2. Статичность: Данные изменяются крайне редко. Нет нагрузки на запись, которая требовала бы распределения.
3. Частое чтение: К этой таблице будут часто обращаться как к справочнику. Размещение ее в виде единственной реплики (или с несколькими read-only репликами для отказоустойчивости) обеспечит максимальную производительность, так как все запросы будут идти к одному месту без необходимости сбора данных с разных шардов.

![горизонтальная схема](https://github.com/noisy441/12-07-replication/blob/main/img/img2.png)

Такой подход позволит создать гибкую и масштабируемую систему, способную эффективно обрабатывать растущую нагрузку при сохранении высокой производительности и надёжности.

---

## Дополнительные задания (со звёздочкой*)
Эти задания дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.

### Задание 3*

Выполните настройку выбранных методов шардинга из задания 2.

*Пришлите конфиг Docker и SQL скрипт с командами для базы данных.*

---

### Решение 3
